Documentation complète

main.py: C’est le fichier de la structure du projet, celui qui regroupe tous les autres et qu’on doit lancer pour avoir accès au jeu.


#### Fonction `copy_state(system: System, player: Player) -> tuple[System, Player]` :
- **Description :** Crée une copie de l'état du système et du joueur, avec toutes les informations de texture/graphiques partagées, pour permettre de les simuler à une vitesse différente de la simulation en temps réel.

#### Fonction `main()` :
- **Description :** Fonction principale du programme. Initialise la fenêtre de jeu, charge les textures et les shaders, met à jour les états du système et du joueur, gère les entrées et le rendu graphique.

#### Fonction `CollisionCheck()` :
- **Description :** Vérifie s'il y a une collision entre le joueur et une planète du système. Renvoie `True` s'il n'y a pas de collision, sinon `False`.


icosphere.py: C’est le fichier qui va servir à donner du relief aux planètes, de générer leur forme et ainsi de ne pas avoir de sphères parfaites.


- **Classe `SimpleMesh` :** Cette classe représente un maillage simple composé de vertices et de faces. Elle permet de créer un maillage raylib à partir des données fournies et est utilisée pour générer une icosaèdre et une icosphère, éléments essentiels dans la création d'un environnement spatial dans le jeu.

- **Fonction `gen_icosahedron()` :** Génère un maillage d'icosaèdre initial avec des vertices et des faces prédéfinis, qui servira de base pour la création de l'icosphère.

- **Fonction `midpoint(a: Vector3, b: Vector3) -> Vector3` :** Calcule le point médian entre deux vecteurs 3D, utilisé lors de la subdivision des triangles pour la création de l'icosphère.

- **Fonction `subdivide(ico: SimpleMesh)` :** Subdivise chaque triangle de l'icosaèdre en 4 nouveaux triangles.

- **Fonction `gen_icosphere(num: int) -> SimpleMesh` :** Crée une icosphère avec un nombre donné de subdivisions, permettant d'obtenir une sphère plus lisse pour représenter les planètes ou autres objets spatiaux dans le jeu.



system.py: S’occupe de la génération des astres dans le jeu ainsi que de leur taille et leur organisation dans le système solaire. 


#### Classe `Planet` :
- **Description :** Représente une entité planétaire dans le système solaire.
  
#### Classe `System` :
- **Description :** Modélise un système solaire composé de plusieurs planètes.
  
#### Méthode `__init__(self, orbit_radius, orbit_center, G, surface_gravity, radius)` (dans la classe `Planet`) :
- **Description :** Initialise une nouvelle instance de planète avec les paramètres donnés.

#### Méthode `orbit(self, G, dt)` (dans la classe `Planet`) :
- **Description :** Simule l'orbite de la planète autour de son centre orbital.

#### Méthode `compute_transform(self)` (dans la classe `Planet`) :
- **Description :** Calcule la transformation de rendu de la planète.

#### Méthode `gen_layer(self)` (dans la classe `Planet`) :
- **Description :** Génère les couches de couleur de la planète en fonction de ses caractéristiques.

#### Méthode `__init__(self, sun)` (dans la classe `System`) :
- **Description :** Initialise un nouveau système solaire avec le soleil donné.

#### Méthode `add(self, planet)` (dans la classe `System`) :
- **Description :** Ajoute une nouvelle planète au système solaire.

#### Méthode `planets(self)` (dans la classe `System`) :
- **Description :** Renvoie un itérateur sur les planètes du système (sans inclure le soleil).

#### Méthode `update(self, G, dt)` (dans la classe `System`) :
- **Description :** Met à jour le système solaire à sa prochaine position.
perlin_noise.py: 

#### Fonction `perlin(x, y, seed=0)` :
- **Description :** Calcule la valeur de bruit de Perlin pour les coordonnées `(x, y)` en utilisant un tableau de permutation aléatoire pour générer un motif de bruit cohérent.

#### Fonction `lerp(a, b, x)` :
- **Description :** Effectue une interpolation linéaire entre les valeurs `a` et `b` en utilisant le coefficient `x`.

#### Fonction `fade(f)` :
- **Description :** Applique une fonction de fondu (fade) à la valeur `f` pour atténuer les transitions brusques entre les valeurs.

#### Fonction `gradient(c, x, y)` :
- **Description :** Calcule les vecteurs de gradient pour une cellule donnée `c` et les coordonnées `x` et `y`, puis effectue un produit scalaire entre ces vecteurs et les distances données.

#### Fonction `gen_perlin(complexity, seed)` :
- **Description :** Génère un motif de bruit de Perlin en créant une grille de coordonnées `x` et `y` à partir d'un tableau linéaire, puis en utilisant la fonction `perlin` pour chaque paire de coordonnées.

#### Fonction `gen_texture(perlin) -> str` :
- **Description :** Crée une image texturée en utilisant le motif de bruit de Perlin fourni, puis sauvegarde cette image dans le dossier "assets" avec un nom de fichier aléatoire. La fonction retourne l'adresse (chemin) de l'image créée.

player.py: représente le joueur dans un environnement virtuel en 3D

#### Classe `Player` :
- **Description :** Représente le joueur dans le jeu, avec sa position, sa vitesse, sa caméra et ses rotations.

#### Méthode `handle_mouse_input(self, dt: float)` :
- **Description :** Met à jour l'angle de vue du joueur en fonction des mouvements de la souris.
- **Paramètres :** `dt` : Temps écoulé depuis la dernière frame.

#### Méthode `handle_keyboard_input(self)` :
- **Description :** Accélère le vaisseau du joueur en fonction des entrées clavier.
  
#### Méthode `apply_gravity(self, G: float, dt: float, bodies: Iterable[Planet])` :
- **Description :** Applique la force gravitationnelle du champ de gravité des planètes sur le joueur.
- **Paramètres :** `G` : Constante gravité. `dt` : Temps écoulé depuis la dernière frame. `bodies` : Iterable de planètes.

#### Méthode `integrate(self, dt: float)` :

- **Description :** Applique la vélocité à la position du joueur.
- **Paramètres :** `dt` : Temps écoulé depuis la dernière frame.

#### Méthode `sync_camera(self)` :
- **Description :** Synchronise la caméra avec les transformations du joueur.


utils.py:  Contient des fonctions et des classes utilitaires pour diverses opérations mathématiques et de manipulation de données.

- **get_projected_sphere_radius**: Cette fonction calcule le rayon projeté d'une sphère sur l'écran en fonction de sa position et de sa taille, afin de gérer la perspective dans le rendu graphique.
- **Quat**: Cette classe représente un quaternion pour la rotation dans l'espace tridimensionnel.
- **vec3_zero**: Cette fonction crée un vecteur tridimensionnel initialisé à zéro.
- **randf**: Cette fonction génère un nombre aléatoire à virgule flottante dans l'intervalle [0, 1].


Et enfin le dossier “assets” qui contient les éléments que nous avons intégré au jeu tels que les différents images de planètes (jupiter, neptune) qui nous ont permis de créer des planètes plus réalistes, par exemple
